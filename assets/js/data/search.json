[
  
  {
    "title": "Git Internals Part 1 - Commits as snapshots",
    "url": "/posts/git-internals-part-1/",
    "categories": "blog",
    "tags": "git, dag",
    "date": "2025-08-14 06:00:00 -0400",
    "content": "The knowledge of Git internals is very helpful for understanding what really happens under the hood when we use commands like git checkout, git commit, and more. This deeper understanding can help you become a more confident Git user, avoid common pitfalls, recover from Git mishaps without fuss, and not always ask ChatGPT when making Git decisions — such as when to use git merge versus git rebase.  This blog series is written for programmers at an advanced beginner stage — those who are already using Git regularly, are comfortable with basic commands, and are familiar with concepts like pointers, references, trees, objects, and hashes.  These posts are not a deep dive into Git’s compression mechanisms or diffing algorithms. Instead, the goal is to walk through Git’s internal data structures just enough so you can feel more secure and in control when working with Git every day.  Here’s the TL;DR of Git internals:     Git’s core data structure is a Directed Acyclic Graph (DAG) whose nodes are commits.   Each commit represents a snapshot of the entire working directory at a particular point in time.   A branch is a pointer to the commit at the tip (leaf node) of the DAG. As new commits are made, the branch pointer automatically moves forward.   HEAD is a special pointer that indicates the currently checked-out commit in your working directory.     A commit is a snapshot of the entire working directory  Since commits are the nodes of Git’s DAG, first we will look at commits more closely.  Git’s objects live in .git/objects  Let’s set up a Git repository so you can follow along.  mkdir root-dir cd root-dir  git init  ls .git              # .git hidden dir is where all the “magic” is stored ls .git/objects      # this is where we’ll focus in this post   The .git folder in the root of the repository contains the entire history: the commit graph, information about remotes, and Git’s internal representation of all files, branches, and objects. Normally, developers never go inside this hidden directory.  Git represents its contents as objects. The objects for Git’s internal storage (files, directories, commits) are stored in .git/objects.  These objects are of three kinds:  type object = blob | tree | commit   Let’s start with blobs.    Files are stored as blobs (compressed) whose name is the hash of the content  Let’s create and add a file, and then see what happens in Git’s storage.  # add file to root echo 'hello world' &gt; first-file.txt  git add -A git status   # Should show `new file: first-file.txt`  ls -l .git/objects         # You should see a new directory `3b` ls -l .git/objects/3b      # Inside, you’ll see `18e512dba79e4c8300dd08aeb37f8e728b8dad`   That long filename is actually the SHA-1 hash of the file’s content plus some metadata. The file itself is stored in a compressed format.  You can confirm this:  git hash-object first-file.txt # Shows the exact hash Git uses as the blob’s filename  cat .git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad # Shows the compressed file content - not human readable  git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad # Shows the uncompressed contents of the blob   So, in short:    Files are stored as blobs inside .git/objects.   The long hash is a SHA-1 of the file’s content + metadata.   The blob’s file content is stored compressed in .git/objects.     Directories are stored as trees  To create a commit we first need a tree. Let’s create our first commit and see what’s added to .git/objects.  git commit -m 'first-commit'  ls .git/objects   # You should see 2 new entries   Git created:    A tree (snapshot of the directory at commit time)   A commit object (points to the tree and has commit metadata)   Let’s figure out which is the tree:  git cat-file -p HEAD # You’ll see something like: # tree 21775babe474ee267168589f0d281c07648284d8   That hash after tree is the tree object. Check that it exists in .git/objects.  Note: Hashing is deterministic, so the same file content and structure should produce the same blob and tree hashes on all machines — unless there are small differences (e.g., line endings, permissions).    Seeing what’s inside a tree  All objects are stored compressed as we saw in case of blob. If you try:  cat .git/objects/21/775babe474ee267168589f0d281c07648284d8  …you’ll see gibberish.  Instead, use:  git cat-file -p 21775babe474ee267168589f0d281c07648284d8 # Example output: # 100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad\tfirst-file.txt   Here:    100644 = file mode (normal file)   blob = type of object   3b18... = blob hash for the file’s contents   first-file.txt = filename   So a tree maps filenames to either blob hashes (files) or other tree hashes (directories).    Adding a nested directory (tree inside a tree)  Let’s add a subdirectory and commit again.  mkdir child-dir echo 'its tough' &gt; child-dir/second-file.txt  git add -A git commit -m 'second-commit'  ls .git/objects # You should see 4 new items (1 blob + 2 trees + 1 commit)   Why 4?    1 new blob for second-file.txt   1 new tree for child-dir   1 new tree for the updated root snapshot   1 new commit object   Remember: every commit stores a snapshot of the entire working directory.  Let’s look at the root tree for the new commit:  git cat-file -p HEAD # Look for the 'tree' line, e.g.: # tree f261fdcc1b954e9c05bb52fe534eba1fc5e86c65   Inspect that tree:  git cat-file -p f261fdcc1b954e9c05bb52fe534eba1fc5e86c65 # Example: # 040000 tree e91bcb85174e47a9c3216c09b9d0fddda1e77ce4\tchild-dir # 100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad\tfirst-file.txt   040000 tree ... child-dir means child-dir is itself a tree. Let’s check it:  git cat-file -p e91bcb85174e47a9c3216c09b9d0fddda1e77ce4 # Example: # 100644 blob 95006b3da6286dc679ced14fdc2f7767387aaed9\tsecond-file.txt   As expected, child-dir contains only second-file.txt.  So we can say the type of a tree is as follows:  type tree = {   [filename_or_dirname: string]: blob | tree }  The strings used as keys are filenames or directory names, which contain a reference to the respective blob or tree. Thus, the hashes themselves are used as references that point to the object in .git/objects.  A directory can contain files or other directories, so trees are defined recursively.  So, in short:    Trees map file or directory names to their hashes in .git/objects.   The hashes are used as references to point to blobs and trees.   Each commit creates a snapshot of the entire tree.     Commits as snapshots  So, finally, what are commits?  # Get the hash for the commit for which HEAD -&gt; main git log    # Then confirm that it actually exists in .git/objects  # Then log its contents. I got the following tree f261fdcc1b954e9c05bb52fe534eba1fc5e86c65 parent 8e62897ae9b96e36689b4907c5b96005140942ad author Shwetank Tewari &lt;shwetank@Shwetanks-MacBook-Pro.local&gt; 1755210443 -0400 committer Shwetank Tewari &lt;shwetank@Shwetanks-MacBook-Pro.local&gt; 1755210443 -0400  second-commit   So a commit is of the following type:  type commit = {   tree: tree   parent: commit[]   message: string   ...other metadata }   The values corresponding to tree and parent are a hash and an array of hashes, respectively, which act as pointers to the tree and other commits. In other words, a commit contains a reference to the tree associated with it and references to the parent commits.  On git checkout &lt;commit_hash&gt;, Git recursively maps the snapshot tree associated with that commit into files and directories, forming the current working directory.    More Practice  # Let's see the content of the tree associated with the current commit git cat-file -p f261fdcc1b954e9c05bb52fe534eba1fc5e86c65  # TODO # 1. Try finding the snapshot tree associated with the first commit # 2. You can get the hash of that commit by git log # 3. Then confirm that the tree contains only the first-file.txt # 4. Then checkout that commit using `git checkout &lt;first_commit_hash&gt;` # 5. Confirm that the current working directory is the same as what we found in step 3 # 6. `git checkout main` to go back to the top commit   So, in short:    A commit is a container that points to a tree (snapshot) and its parent commit(s).   The tree entry points to the root directory snapshot of that commit.   The parent entries point to one or more earlier commits.   git checkout replaces your working directory with the files and directories from that tree.     That’s all for now. I hope you now have a better understanding of how Git stores the files and directories and how git checkout modifies the current working directory.  In the next part, we will look at what the Git DAG is and try to make better mental models of branches and HEAD.  Till next time, Auf Wiedersehen. "
  }
  
]

